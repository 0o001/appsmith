import AutoHeightContainerWrapper from "components/autoHeight/AutoHeightContainerWrapper";
import PositionedContainer from "components/designSystems/appsmith/PositionedContainer";
import {
  GridDefaults,
  RenderModes,
  WIDGET_PADDING,
} from "constants/WidgetConstants";
import type { ReactNode } from "react";
import React from "react";
import type { WidgetProps, WidgetState } from "./BaseWidget";
import Skeleton from "./Skeleton";
import {
  getWidgetMaxAutoHeight,
  getWidgetMinAutoHeight,
  isAutoHeightEnabledForWidget,
  isAutoHeightEnabledForWidgetWithLimits,
  shouldUpdateWidgetHeightAutomatically,
} from "./WidgetUtils";
import type BaseWidget from "./BaseWidget";
import type { CSSProperties } from "styled-components";
import { ReduxActionTypes } from "@appsmith/constants/ReduxActionConstants";
import AnalyticsUtil from "utils/AnalyticsUtil";
import AutoHeightOverlayContainer from "components/autoHeightOverlay";

export const getFixedLayoutProps = (
  props: WidgetProps,
  baseWidgetContext: BaseWidget<WidgetProps, WidgetState>,
) => {
  const calculateWidgetBounds = (
    rightColumn: number,
    leftColumn: number,
    topRow: number,
    bottomRow: number,
    parentColumnSpace: number,
    parentRowSpace: number,
  ): {
    componentWidth: number;
    componentHeight: number;
  } => {
    return {
      componentWidth: (rightColumn - leftColumn) * parentColumnSpace,
      componentHeight: (bottomRow - topRow) * parentRowSpace,
    };
  };

  const getWidgetComponent = (widgetContent: ReactNode) => {
    const { type } = props;

    /**
     * The widget mount calls the withWidgetProps with the widgetId and type to fetch the
     * widget props. During the computation of the props (in withWidgetProps) if the evaluated
     * values are not present (which will not be during mount), the widget type is changed to
     * SKELETON_WIDGET.
     *
     * Note:- This is done to retain the old rendering flow without any breaking changes.
     * This could be refactored into not changing the widget type but to have a boolean flag.
     */
    if (type === "SKELETON_WIDGET" || props.deferRender) {
      return <Skeleton />;
    }

    let content = widgetContent;

    // This `if` code is responsible for the unmount of the widgets
    // while toggling the dynamicHeight property
    // Adding a check for the Modal Widget early
    // to avoid deselect Modal in its unmount effect.
    if (
      isAutoHeightEnabledForWidget(props) &&
      !props.isAutoGeneratedWidget && // To skip list widget's auto generated widgets
      !props.detachFromLayout // To skip Modal widget issue #18697
    ) {
      return (
        <AutoHeightContainerWrapper
          onUpdateDynamicHeight={(height) => updateAutoHeight(height)}
          widgetProps={props}
        >
          {content}
        </AutoHeightContainerWrapper>
      );
    }

    content = baseWidgetContext.addWidgetComponentBoundary(content, props);
    return baseWidgetContext.addErrorBoundary(content);
  };

  /*
  This method calls the action to update widget height
  We're not using `updateWidgetProperty`, because, the workflow differs
  We will be computing properties of all widgets which are effected by
  this change.
  @param height number: Height of the widget's contents in pixels
  @return void

  TODO (abhinav): Make sure that this isn't called for scenarios which do not require it
  This is for performance. We don't want unnecessary code to run
*/
  const updateAutoHeight = (height: number): void => {
    const paddedHeight =
      Math.ceil(
        Math.ceil(height + WIDGET_PADDING * 2) /
          GridDefaults.DEFAULT_GRID_ROW_HEIGHT,
      ) * GridDefaults.DEFAULT_GRID_ROW_HEIGHT;

    const shouldUpdate = shouldUpdateWidgetHeightAutomatically(
      paddedHeight,
      props,
    );
    const { updateWidgetAutoHeight } = baseWidgetContext.context;

    if (updateWidgetAutoHeight) {
      const { widgetId } = props;
      shouldUpdate && updateWidgetAutoHeight(widgetId, paddedHeight);
    }
  };

  const addAutoHeightOverlay = (content: ReactNode, style?: CSSProperties) => {
    // required when the limits have to be updated
    // simultaneosuly when they move together
    // to maintain the undo/redo stack
    const onBatchUpdate = ({
      maxHeight,
      minHeight,
    }: {
      maxHeight?: number;
      minHeight?: number;
    }) => {
      const modifyObj: Record<string, unknown> = {};

      if (maxHeight !== undefined) {
        modifyObj["maxDynamicHeight"] = Math.floor(
          maxHeight / GridDefaults.DEFAULT_GRID_ROW_HEIGHT,
        );
      }

      if (minHeight !== undefined) {
        modifyObj["minDynamicHeight"] = Math.floor(
          minHeight / GridDefaults.DEFAULT_GRID_ROW_HEIGHT,
        );
      }

      baseWidgetContext.batchUpdateWidgetProperty({
        modify: modifyObj,
        postUpdateAction: ReduxActionTypes.CHECK_CONTAINERS_FOR_AUTO_HEIGHT,
      });
      AnalyticsUtil.logEvent("AUTO_HEIGHT_OVERLAY_HANDLES_UPDATE", modifyObj);
    };

    const onMaxHeightSet = (maxHeight: number) => onBatchUpdate({ maxHeight });

    const onMinHeightSet = (minHeight: number) => onBatchUpdate({ minHeight });

    return (
      <>
        <AutoHeightOverlayContainer
          {...props}
          batchUpdate={onBatchUpdate}
          maxDynamicHeight={getWidgetMaxAutoHeight(props)}
          minDynamicHeight={getWidgetMinAutoHeight(props)}
          onMaxHeightSet={onMaxHeightSet}
          onMinHeightSet={onMinHeightSet}
          style={style}
        />
        {content}
      </>
    );
  };

  const makePositioned = (content: ReactNode) => {
    const { componentHeight, componentWidth } = getComponentDimensions();

    return (
      <PositionedContainer
        componentHeight={componentHeight}
        componentWidth={componentWidth}
        focused={props.focused}
        isDisabled={props.isDisabled}
        isVisible={props.isVisible}
        leftColumn={props.leftColumn}
        noContainerOffset={props.noContainerOffset}
        parentColumnSpace={props.parentColumnSpace}
        parentId={props.parentId}
        parentRowSpace={props.parentRowSpace}
        ref={props.wrapperRef}
        resizeDisabled={props.resizeDisabled}
        selected={props.selected}
        topRow={props.topRow}
        widgetId={props.widgetId}
        widgetName={props.widgetName}
        widgetType={props.type}
      >
        {content}
      </PositionedContainer>
    );
  };

  const getWidgetView = (widgetContent: ReactNode): ReactNode => {
    let content: ReactNode;

    switch (props.renderMode) {
      case RenderModes.CANVAS:
        content = getWidgetComponent(widgetContent);
        if (!props.detachFromLayout) {
          if (!props.resizeDisabled && props.type !== "SKELETON_WIDGET")
            content = baseWidgetContext.makeResizable(content);
          content = baseWidgetContext.showWidgetName(content);
          content = baseWidgetContext.makeDraggable(content);
          content = baseWidgetContext.makeSnipeable(content);

          content = makePositioned(content);

          if (isAutoHeightEnabledForWidgetWithLimits(props)) {
            content = addAutoHeightOverlay(content);
          }
        }

        return content;

      // return getCanvasView();
      case RenderModes.PAGE:
        content = getWidgetComponent(widgetContent);
        if (!props.detachFromLayout) {
          content = makePositioned(content);
        }
        return content;
      default:
        throw Error("RenderMode not defined");
    }
  };

  const getComponentDimensions = () => {
    return calculateWidgetBounds(
      props.rightColumn,
      props.leftColumn,
      props.topRow,
      props.bottomRow,
      props.parentColumnSpace,
      props.parentRowSpace,
    );
  };

  return {
    getComponentDimensions: getComponentDimensions,
    getWidgetView: getWidgetView,
  };
};
